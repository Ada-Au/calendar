### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AffectedRowsOutput {
  count: Int!
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createOneUser(data: UserCreateInput!): User!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  """Get my user data"""
  me: User
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  usersCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

"""Task for event on calendar."""
type Task {
  """check if event is completed."""
  completed: Boolean!
  createdAt: String!
  description: String

  """The starting time of event. Must be set if not full day."""
  endTime: String
  id: ID!

  """Show that the event is full day. Default as fault"""
  isFullDay: Boolean!

  """
  The starting time of event. Default as create time. Use for getting the date if event is full day.
  """
  startTime: String!
  title: String!
}

"""The User Account data."""
type User {
  """The timestamp (UTC in ISO 9601 Standard) this user was created."""
  createdAt: DateTime!

  """
  The user email used to create and uniquely identify this account and user data.
  """
  email: String!
  id: Int!

  """The name of the user."""
  name: String!

  """The user account password."""
  password: String!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  password: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
